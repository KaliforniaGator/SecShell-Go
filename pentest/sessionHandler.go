package pentest

import (
	"fmt"
	"io"
	"net"
	"os"
	"secshell/drawbox"
	"secshell/logging"
	"strconv"
	"strings"
	"sync"
	"time"

	"golang.org/x/term"
)

// Sessions map to track active sessions
var Sessions = make(map[int]*Session)
var nextSessionID = 1
var sessionMutex sync.Mutex

// Session represents a reverse shell or other connection
type Session struct {
	ID         int
	Type       string // "listener" or "client"
	Target     string
	Port       int
	StartTime  time.Time
	Conn       net.Conn
	Listener   net.Listener
	Active     bool
	mutex      sync.Mutex
	ExitSignal chan bool
}

// ListenForConnections starts a listener for incoming reverse shells
func ListenForConnections(port string) int {
	portNum, err := strconv.Atoi(port)
	if err != nil {
		logging.LogError(err)
		drawbox.PrintError("Invalid port number")
		return -1
	}

	drawbox.RunDrawbox(fmt.Sprintf("Starting listener on port %s", port), "bold_green")

	// Create a session entry
	sessionMutex.Lock()
	session := &Session{
		ID:         nextSessionID,
		Type:       "listener",
		Target:     "any",
		Port:       portNum,
		StartTime:  time.Now(),
		Active:     true,
		ExitSignal: make(chan bool),
	}
	nextSessionID++
	sessionMutex.Unlock()

	// Start listener goroutine
	go func() {
		listener, err := net.Listen("tcp", ":"+port)
		if err != nil {
			logging.LogError(err)
			drawbox.PrintError(fmt.Sprintf("Failed to start listener: %s", err))
			session.mutex.Lock()
			session.Active = false
			session.mutex.Unlock()
			return
		}

		session.mutex.Lock()
		session.Listener = listener
		session.mutex.Unlock()

		fmt.Printf("Listening on 0.0.0.0:%s...\n", port)
		fmt.Printf("Waiting for connections. Use 'session -i %d' to interact when a connection arrives.\n", session.ID)

		// Accept connections
		go func() {
			for {
				conn, err := listener.Accept()
				if err != nil {
					select {
					case <-session.ExitSignal:
						return // Listener was closed intentionally
					default:
						logging.LogError(err)
						drawbox.PrintError(fmt.Sprintf("Error accepting connection: %s", err))
						continue
					}
				}

				// Update session with the new connection
				session.mutex.Lock()
				session.Conn = conn
				session.Target = conn.RemoteAddr().String()
				session.Active = true
				session.mutex.Unlock()

				// Print notification
				drawbox.PrintAlert(fmt.Sprintf("Connection received from %s on session %d!", conn.RemoteAddr().String(), session.ID))

				// Handle potential disconnection
				go func() {
					// Just wait for connection to close
					buffer := make([]byte, 1)
					for {
						_, err := conn.Read(buffer)
						if err != nil {
							if err != io.EOF {
								logging.LogError(err)
							}

							session.mutex.Lock()
							session.Conn = nil
							session.mutex.Unlock()

							drawbox.PrintError(fmt.Sprintf("Connection from %s closed", conn.RemoteAddr().String()))
							break
						}
					}
				}()
			}
		}()

		// Wait for exit signal
		<-session.ExitSignal
		listener.Close()
	}()

	// Store the session
	sessionMutex.Lock()
	Sessions[session.ID] = session
	sessionMutex.Unlock()

	return session.ID
}

// ListSessions shows all active sessions
func ListSessions() {
	drawbox.RunDrawbox("Active Sessions", "bold_blue")

	sessionMutex.Lock()
	defer sessionMutex.Unlock()

	if len(Sessions) == 0 {
		fmt.Println("No active sessions")
		return
	}

	fmt.Printf("%-5s %-12s %-20s %-8s %-15s\n", "ID", "Type", "Target", "Port", "Started")
	fmt.Println(strings.Repeat("-", 60))

	for _, s := range Sessions {
		s.mutex.Lock()
		fmt.Printf("%-5d %-12s %-20s %-8d %s\n",
			s.ID, s.Type, s.Target, s.Port,
			s.StartTime.Format("15:04:05"))
		s.mutex.Unlock()
	}
}

// InteractWithSession starts an interactive session with the given session ID
func InteractWithSession(id int) {
	sessionMutex.Lock()
	session, ok := Sessions[id]
	sessionMutex.Unlock()

	if !ok {
		drawbox.PrintError(fmt.Sprintf("Session %d not found", id))
		return
	}

	session.mutex.Lock()
	if session.Conn == nil {
		if session.Type == "listener" {
			session.mutex.Unlock()
			drawbox.PrintError(fmt.Sprintf("Session %d is waiting for connection", id))
			return
		} else {
			session.mutex.Unlock()
			drawbox.PrintError(fmt.Sprintf("Session %d is not connected", id))
			return
		}
	}

	conn := session.Conn
	target := session.Target
	session.mutex.Unlock()

	drawbox.RunDrawbox(fmt.Sprintf("Interactive Session %d with %s", id, target), "bold_green")
	fmt.Println("Type 'exit' to return to SecShell (connection will remain active)")
	fmt.Println(strings.Repeat("-", 60))

	// Send initial command to get a prompt
	conn.Write([]byte("echo SecShell connected\n"))

	// Set up stdin for raw mode
	oldState, err := setRawTerminal()
	if err != nil {
		logging.LogError(err)
		drawbox.PrintError("Failed to set terminal to raw mode")
		return
	}
	defer restoreTerminal(oldState)

	// Handle input/output in goroutines
	inputChan := make(chan bool)
	outputChan := make(chan bool)

	// Handle user input
	go func() {
		defer close(inputChan)

		buffer := make([]byte, 1024)
		for {
			n, err := os.Stdin.Read(buffer)
			if err != nil {
				break
			}

			// Check for exit command
			if string(buffer[:n]) == "exit\r\n" || string(buffer[:n]) == "exit\n" {
				break
			}

			// Forward input to connection
			_, err = conn.Write(buffer[:n])
			if err != nil {
				break
			}
		}

		inputChan <- true
	}()

	// Handle output from connection
	go func() {
		defer close(outputChan)

		buffer := make([]byte, 4096)
		for {
			n, err := conn.Read(buffer)
			if err != nil {
				if err != io.EOF {
					logging.LogError(err)
				}
				break
			}

			// Print to stdout
			os.Stdout.Write(buffer[:n])
		}

		outputChan <- true
	}()

	// Wait for either channel to close
	select {
	case <-inputChan:
		// User exited
	case <-outputChan:
		// Connection closed
		session.mutex.Lock()
		session.Conn = nil
		session.mutex.Unlock()
		fmt.Println("\nConnection closed by remote host")
	}
}

// CloseSession closes and removes a session
func CloseSession(id int) bool {
	sessionMutex.Lock()
	session, ok := Sessions[id]
	if !ok {
		sessionMutex.Unlock()
		drawbox.PrintError(fmt.Sprintf("Session %d not found", id))
		return false
	}
	sessionMutex.Unlock()

	session.mutex.Lock()
	defer session.mutex.Unlock()

	// Close connection if it exists
	if session.Conn != nil {
		session.Conn.Close()
		session.Conn = nil
	}

	// Close listener if it exists
	if session.Listener != nil {
		// Signal the listener goroutine to exit
		close(session.ExitSignal)
		session.Listener.Close()
		session.Listener = nil
	}

	session.Active = false

	// Remove from sessions map
	sessionMutex.Lock()
	delete(Sessions, id)
	sessionMutex.Unlock()

	drawbox.PrintAlert(fmt.Sprintf("Session %d closed", id))
	return true
}

// Helper functions for terminal handling
func setRawTerminal() (*term.State, error) {
	// Put terminal into raw mode to handle control characters correctly
	// Save the original state so we can restore it later
	fd := int(os.Stdin.Fd())
	oldState, err := term.MakeRaw(fd)
	if err != nil {
		return nil, fmt.Errorf("failed to set terminal to raw mode: %v", err)
	}
	return oldState, nil
}

func restoreTerminal(state *term.State) {
	// Restore terminal to its original state
	if state != nil {
		fd := int(os.Stdin.Fd())
		err := term.Restore(fd, state)
		if err != nil {
			logging.LogError(fmt.Errorf("failed to restore terminal state: %v", err))
		}
	}
}
