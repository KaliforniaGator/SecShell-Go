package pentest

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"net"
	"os"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"text/tabwriter"
	"time"

	"secshell/drawbox"
	"secshell/logging"
	"secshell/ui/gui"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
)

// ScanResult stores the result of a port scan
type ScanResult struct {
	Port     int
	State    string
	Service  string
	Version  string
	Protocol string
}

// ScanOptions contains configuration for port scanning
type ScanOptions struct {
	Protocol       string // tcp or udp
	Timing         int    // 1-5, controls scan timing
	ShowVersion    bool   // attempt version detection
	Format         string // output format (text, json, html)
	OutputFile     string // file to write results to
	StealthMode    bool   // Slower, randomized scanning
	ExcludePorts   []int  // Ports to skip
	ServiceProbes  bool   // Enhanced service detection
	BannerGrab     bool   // Attempt banner grabbing
	RandomizeOrder bool   // Randomize port order
	SynScan        bool   // Use SYN scanning (requires root)
	DetectOS       bool   // Attempt OS detection
	EnhancedDetect bool   // Use enhanced service detection
}

// RunPortScan performs a port scan using native Go networking
func RunPortScan(target string, portRange string, options *ScanOptions) {
	if options == nil {
		options = &ScanOptions{
			Protocol:    "tcp",
			Timing:      3,
			ShowVersion: false,
			Format:      "text",
			OutputFile:  "",
		}
	}

	if portRange == "" {
		portRange = "1-1000" // Default port range
	}

	gui.InfoBox(fmt.Sprintf("Port Scan for %s (ports %s, proto %s)",
		target, portRange, options.Protocol))

	// Parse port range
	start, end := parsePortRange(portRange)
	if start < 1 || end > 65535 || start > end {
		gui.ErrorBox("Invalid port range. Must be between 1-65535")
		return
	}

	fmt.Printf("Starting scan on %s (%d ports)\n", target, end-start+1)
	startTime := time.Now()

	// Resolve IP address
	ips, err := net.LookupIP(target)
	if err != nil || len(ips) == 0 {
		logging.LogError(fmt.Errorf("could not resolve %s: %v", target, err))
		gui.ErrorBox(fmt.Sprintf("Could not resolve host: %s", target))
		return
	}

	ip := ips[0].String()
	fmt.Printf("Scanning IP: %s\n\n", ip)

	// Add OS detection if enabled
	if options.DetectOS {
		os := detectOS(ip)
		fmt.Printf("\nDetected Operating System: %s\n\n", os)
	}

	// Adjust timeout based on timing
	timeout := time.Duration(6-options.Timing) * time.Second

	// Start scanning ports with options
	results := scanPorts(ip, start, end, options, timeout)

	// Print and save results based on format
	saveResults(results, options)

	fmt.Printf("\nScan completed in %.2f seconds\n", time.Since(startTime).Seconds())
}

// parsePortRange converts a string like "80-100" into start and end integers
func parsePortRange(portRange string) (int, int) {
	parts := strings.Split(portRange, "-")
	if len(parts) == 1 {
		// Single port
		port, _ := strconv.Atoi(parts[0])
		return port, port
	}

	// Port range
	start, _ := strconv.Atoi(parts[0])
	end, _ := strconv.Atoi(parts[1])
	return start, end
}

func scanPorts(ip string, start, end int, options *ScanOptions, timeout time.Duration) []ScanResult {
	var results []ScanResult
	var mutex sync.Mutex
	var wg sync.WaitGroup
	totalPorts := end - start + 1
	scanned := 0

	// Progress bar setup
	progressChan := make(chan struct{})
	go showProgress(&scanned, totalPorts, progressChan)

	// Adjust concurrency based on timing
	maxConcurrent := options.Timing * 100
	semaphore := make(chan struct{}, maxConcurrent)

	for port := start; port <= end; port++ {
		wg.Add(1)
		semaphore <- struct{}{}

		go func(p int) {
			defer wg.Done()
			defer func() { <-semaphore }()

			var state string
			var service string
			var version string

			// Use SYN scan if enabled and running as root
			if options.SynScan {
				state, service = scanTCPSyn(ip, p)
				if state == "error" {
					// Fallback to regular scan if SYN scan fails
					state, service = scanTCPPort(ip, p, timeout)
				}
			} else if options.Protocol == "udp" {
				state, service = scanUDPPort(ip, p, timeout)
			} else {
				state, service = scanTCPPort(ip, p, timeout)
			}

			// Use enhanced service detection if enabled
			if state == "open" && options.EnhancedDetect {
				service, version = enhancedServiceDetection(ip, p)
			} else if state == "open" && options.ShowVersion {
				version = detectVersion(ip, p, service)
			}

			if state == "open" {
				mutex.Lock()
				results = append(results, ScanResult{
					Port:     p,
					State:    state,
					Service:  service,
					Version:  version,
					Protocol: options.Protocol,
				})
				fmt.Printf("\rFound open port: %d/%s/%s %s",
					p, options.Protocol, service, version)
				mutex.Unlock()
			}

			mutex.Lock()
			scanned++
			mutex.Unlock()
		}(port)
	}

	wg.Wait()
	close(progressChan) // Stop progress bar
	fmt.Println()
	return results
}

func showProgress(current *int, total int, done chan struct{}) {
	width := 40
	for {
		select {
		case <-done:
			return
		default:
			progress := float64(*current) / float64(total)
			filled := int(progress * float64(width))
			bar := strings.Repeat("=", filled) + strings.Repeat("-", width-filled)
			fmt.Printf("\r[%s] %.1f%% (%d/%d)", bar, progress*100, *current, total)
			time.Sleep(100 * time.Millisecond)
		}
	}
}

func scanTCPPort(ip string, port int, timeout time.Duration) (string, string) {
	address := net.JoinHostPort(ip, strconv.Itoa(port))
	conn, err := net.DialTimeout("tcp", address, timeout)

	if err == nil {
		defer conn.Close()
		return "open", getServiceName(port)
	}
	return "closed", ""
}

func scanUDPPort(ip string, port int, timeout time.Duration) (string, string) {
	addr := net.JoinHostPort(ip, strconv.Itoa(port))
	conn, err := net.DialTimeout("udp", addr, timeout)
	if err != nil {
		return "closed", ""
	}
	defer conn.Close()

	// Send a UDP packet and try to get a response
	conn.SetDeadline(time.Now().Add(timeout))
	conn.Write([]byte{0})

	buffer := make([]byte, 1024)
	_, err = conn.Read(buffer)
	if err == nil {
		return "open", getServiceName(port)
	}

	return "open|filtered", getServiceName(port)
}

func detectVersion(ip string, port int, service string) string {
	addr := net.JoinHostPort(ip, strconv.Itoa(port))
	conn, err := net.DialTimeout("tcp", addr, time.Second*2)
	if err != nil {
		return ""
	}
	defer conn.Close()

	// Send appropriate probe based on service
	probe := getServiceProbe(service)
	conn.Write([]byte(probe))

	// Read response
	buffer := make([]byte, 1024)
	conn.SetReadDeadline(time.Now().Add(time.Second * 2))
	n, err := conn.Read(buffer)
	if err != nil {
		return ""
	}

	return parseVersion(service, string(buffer[:n]))
}

func getServiceProbe(service string) string {
	probes := map[string]string{
		"http":    "GET / HTTP/1.0\r\n\r\n",
		"ssh":     "SSH-2.0-SecShell\r\n",
		"ftp":     "USER anonymous\r\n",
		"smtp":    "HELO SecShell\r\n",
		"pop3":    "CAPA\r\n",
		"mysql":   "\x0a",
		"default": "\r\n",
	}

	if probe, ok := probes[service]; ok {
		return probe
	}
	return probes["default"]
}

func parseVersion(service, response string) string {
	// Common version extraction patterns
	patterns := map[string]string{
		"http":  `Server: ([^\r\n]+)`,
		"ssh":   `SSH-2.0-([^\r\n]+)`,
		"ftp":   `220-([^\r\n]+)`,
		"smtp":  `220 ([^\r\n]+)`,
		"pop3":  `\+OK ([^\r\n]+)`,
		"mysql": `([0-9]+\.[0-9]+\.[0-9]+)`,
	}

	if pattern, ok := patterns[service]; ok {
		re := regexp.MustCompile(pattern)
		if match := re.FindStringSubmatch(response); len(match) > 1 {
			return match[1]
		}
	}

	return ""
}

// Update saveResults to use printResults for additional output formats
func saveResults(results []ScanResult, options *ScanOptions) {
	// Print results to screen using the enhanced printResults function
	printResults(results, options.Format)

	// Only proceed with file output if specified
	if options.OutputFile == "" {
		return
	}

	// Prepare output in requested format
	var output string
	switch options.Format {
	case "json":
		if jsonData, err := json.MarshalIndent(results, "", "  "); err == nil {
			output = string(jsonData)
		}
	case "html":
		output = generateHTML(results)
	default:
		var sb strings.Builder
		sb.WriteString(fmt.Sprintf("%-6s %-6s %-10s %-15s %s\n", "PORT", "PROTO", "STATE", "SERVICE", "VERSION"))
		sb.WriteString(strings.Repeat("-", 70) + "\n")
		for _, result := range results {
			sb.WriteString(fmt.Sprintf("%-6d %-6s %-10s %-15s %s\n",
				result.Port, result.Protocol, result.State,
				result.Service, result.Version))
		}
		output = sb.String()
	}

	// Save to file
	err := os.WriteFile(options.OutputFile, []byte(output), 0644)
	if err != nil {
		gui.ErrorBox(fmt.Sprintf("Failed to write to output file: %s", err))
		return
	}
	drawbox.PrintAlert(fmt.Sprintf("Results saved to: %s", options.OutputFile))
}

func generateHTML(results []ScanResult) string {
	var html strings.Builder
	html.WriteString(`<!DOCTYPE html>
<html>
<head>
    <title>Port Scan Results</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .open { color: green; }
        .closed { color: red; }
    </style>
</head>
<body>
    <h1>Port Scan Results</h1>
    <table>
        <tr>
            <th>Port</th>
            <th>Protocol</th>
            <th>State</th>
            <th>Service</th>
            <th>Version</th>
        </tr>`)

	for _, result := range results {
		stateClass := "closed"
		if result.State == "open" {
			stateClass = "open"
		}
		html.WriteString(fmt.Sprintf(`
        <tr>
            <td>%d</td>
            <td>%s</td>
            <td class="%s">%s</td>
            <td>%s</td>
            <td>%s</td>
        </tr>`, result.Port, result.Protocol, stateClass, result.State, result.Service, result.Version))
	}

	html.WriteString(`
    </table>
    <p><small>Generated by SecShell Port Scanner</small></p>
</body>
</html>`)

	return html.String()
}

func printResults(results []ScanResult, format string) {
	switch format {
	case "json":
		if jsonData, err := json.MarshalIndent(results, "", "  "); err == nil {
			fmt.Println(string(jsonData))
			return
		}
	case "csv":
		w := csv.NewWriter(os.Stdout)
		w.Write([]string{"Port", "Protocol", "State", "Service", "Version"})
		for _, result := range results {
			w.Write([]string{
				strconv.Itoa(result.Port),
				result.Protocol,
				result.State,
				result.Service,
				result.Version,
			})
		}
		w.Flush()
	case "xml":
		fmt.Println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
		fmt.Println("<scan>")
		for _, result := range results {
			fmt.Printf("  <port number=\"%d\" protocol=\"%s\">\n", result.Port, result.Protocol)
			fmt.Printf("    <state>%s</state>\n", result.State)
			fmt.Printf("    <service>%s</service>\n", result.Service)
			fmt.Printf("    <version>%s</version>\n", result.Version)
			fmt.Printf("  </port>\n")
		}
		fmt.Println("</scan>")
	default:
		// Table format
		w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
		fmt.Fprintln(w, "PORT\tPROTO\tSTATE\tSERVICE\tVERSION")
		fmt.Fprintln(w, strings.Repeat("-", 70))
		for _, result := range results {
			fmt.Fprintf(w, "%d\t%s\t%s\t%s\t%s\n",
				result.Port, result.Protocol, result.State,
				result.Service, result.Version)
		}
		w.Flush()
	}
}

// getServiceName returns a service name for common ports
func getServiceName(port int) string {
	services := map[int]string{
		20:    "ftp-data",
		21:    "ftp",
		22:    "ssh",
		23:    "telnet",
		25:    "smtp",
		53:    "dns",
		67:    "dhcp",
		68:    "dhcp",
		69:    "tftp",
		80:    "http",
		88:    "kerberos",
		110:   "pop3",
		111:   "rpcbind",
		123:   "ntp",
		137:   "netbios-ns",
		138:   "netbios-dgm",
		139:   "netbios-ssn",
		143:   "imap",
		161:   "snmp",
		162:   "snmp-trap",
		389:   "ldap",
		443:   "https",
		445:   "smb",
		465:   "smtps",
		514:   "syslog",
		515:   "printer",
		587:   "submission",
		631:   "ipp",
		636:   "ldaps",
		993:   "imaps",
		995:   "pop3s",
		1080:  "socks",
		1433:  "mssql",
		1521:  "oracle",
		1701:  "l2tp",
		1723:  "pptp",
		1900:  "upnp",
		2049:  "nfs",
		2082:  "cpanel",
		2083:  "cpanel-ssl",
		2086:  "whm",
		2087:  "whm-ssl",
		3128:  "squid",
		3306:  "mysql",
		3389:  "rdp",
		3690:  "svn",
		5432:  "postgresql",
		5900:  "vnc",
		5901:  "vnc-1",
		5902:  "vnc-2",
		5903:  "vnc-3",
		6379:  "redis",
		6660:  "irc",
		6661:  "irc",
		6662:  "irc",
		6663:  "irc",
		6664:  "irc",
		6665:  "irc",
		6666:  "irc",
		6667:  "irc",
		6668:  "irc",
		6669:  "irc",
		8080:  "http-alt",
		8443:  "https-alt",
		9000:  "portmap",
		9001:  "tor-orport",
		9090:  "websm",
		9100:  "jetdirect",
		9200:  "elasticsearch",
		10000: "webmin",
		27017: "mongodb",
		28017: "mongodb-web",
		50000: "db2",
		50070: "hadoop",
		54321: "postgresql",
	}

	if service, ok := services[port]; ok {
		return service
	}
	return "unknown"
}

// RunHostDiscovery performs host discovery on a network
func RunHostDiscovery(network string) {
	drawbox.RunDrawbox(fmt.Sprintf("Host Discovery on %s", network), "bold_cyan")

	// Parse CIDR notation
	ip, ipnet, err := net.ParseCIDR(network)
	if err != nil {
		logging.LogError(err)
		gui.ErrorBox(fmt.Sprintf("Invalid network format: %s (use CIDR notation, e.g., 192.168.1.0/24)", network))
		return
	}

	fmt.Printf("Scanning network: %s\n\n", network)
	startTime := time.Now()

	var ips []net.IP
	for ip := ip.Mask(ipnet.Mask); ipnet.Contains(ip); incrementIP(ip) {
		ips = append(ips, duplicateIP(ip))
	}

	if len(ips) > 2 {
		ips = ips[1 : len(ips)-1]
	}

	totalHosts := len(ips)
	fmt.Printf("Scanning %d potential hosts...\n\n", totalHosts)

	var wg sync.WaitGroup
	var mutex sync.Mutex
	var liveHosts []string
	scanned := 0

	// Progress bar setup
	progressChan := make(chan struct{})
	go showProgress(&scanned, totalHosts, progressChan)

	semaphore := make(chan struct{}, 100)

	for _, ip := range ips {
		wg.Add(1)
		semaphore <- struct{}{}

		go func(ipAddr net.IP) {
			defer wg.Done()
			defer func() { <-semaphore }()

			isAlive := pingHost(ipAddr.String())

			if !isAlive {
				commonPorts := []int{80, 443, 22, 21, 3389}
				for _, port := range commonPorts {
					address := net.JoinHostPort(ipAddr.String(), strconv.Itoa(port))
					conn, err := net.DialTimeout("tcp", address, 500*time.Millisecond)
					if err == nil {
						conn.Close()
						isAlive = true
						break
					}
				}
			}

			mutex.Lock()
			scanned++
			if isAlive {
				liveHosts = append(liveHosts, ipAddr.String())
				fmt.Printf("\rFound live host: %-15s", ipAddr.String())
				fmt.Println()
			}
			mutex.Unlock()
		}(ip)
	}

	wg.Wait()
	close(progressChan)
	fmt.Println()

	// Print results in a formatted table
	fmt.Printf("Scan completed in %.2f seconds\n", time.Since(startTime).Seconds())
	fmt.Printf("Found %d live hosts out of %d total hosts (%.1f%%)\n",
		len(liveHosts), totalHosts, float64(len(liveHosts))/float64(totalHosts)*100)
	fmt.Println(strings.Repeat("-", 60))
	fmt.Printf("%-16s %-40s\n", "IP Address", "Hostname")
	fmt.Println(strings.Repeat("-", 60))

	for _, host := range liveHosts {
		hostnames, _ := net.LookupAddr(host)
		hostname := "N/A"
		if len(hostnames) > 0 {
			hostname = hostnames[0]
		}
		fmt.Printf("%-16s %-40s\n", host, hostname)
	}
	fmt.Println(strings.Repeat("-", 60))
}

// incrementIP increments an IP address by 1
func incrementIP(ip net.IP) {
	for i := len(ip) - 1; i >= 0; i-- {
		ip[i]++
		if ip[i] > 0 {
			break
		}
	}
}

// duplicateIP creates a copy of an IP address
func duplicateIP(ip net.IP) net.IP {
	dup := make(net.IP, len(ip))
	copy(dup, ip)
	return dup
}

// pingHost attempts to ping a host
func pingHost(ip string) bool {
	// Simple connect to echo port (port 7)
	conn, err := net.DialTimeout("tcp", ip+":7", 500*time.Millisecond)
	if err == nil {
		conn.Close()
		return true
	}

	// Try a TCP ping to port 80
	conn, err = net.DialTimeout("tcp", ip+":80", 500*time.Millisecond)
	if err == nil {
		conn.Close()
		return true
	}

	return false
}

// enhancedServiceDetection implements advanced service fingerprinting
func enhancedServiceDetection(ip string, port int) (string, string) {
	addr := net.JoinHostPort(ip, strconv.Itoa(port))
	service := "unknown"
	version := ""

	// Try multiple connection attempts with different probes
	probes := []struct {
		probe    []byte
		timeout  time.Duration
		protocol string
	}{
		{[]byte("HEAD / HTTP/1.0\r\n\r\n"), 2 * time.Second, "tcp"},
		{[]byte{0x16, 0x03, 0x01, 0x00, 0x50}, 2 * time.Second, "tcp"}, // TLS probe
		{[]byte("HELP\r\n"), 1 * time.Second, "tcp"},
		{[]byte{0x00}, 1 * time.Second, "udp"},
	}

	for _, p := range probes {
		conn, err := net.DialTimeout(p.protocol, addr, p.timeout)
		if err != nil {
			continue
		}
		defer conn.Close()

		conn.SetDeadline(time.Now().Add(p.timeout))
		conn.Write(p.probe)

		buf := make([]byte, 1024)
		n, err := conn.Read(buf)
		if err != nil {
			continue
		}

		response := string(buf[:n])

		// Check for TLS
		if bytes.HasPrefix(buf, []byte{0x16, 0x03}) {
			service = "tls"
			if n > 5 {
				version = fmt.Sprintf("TLS %d.%d", buf[1], buf[2])
			}
			break
		}

		// HTTP detection
		if strings.Contains(response, "HTTP/") {
			service = "http"
			re := regexp.MustCompile(`Server: ([^\r\n]+)`)
			if matches := re.FindStringSubmatch(response); len(matches) > 1 {
				version = matches[1]
			}
			break
		}

		// SSH detection
		if strings.HasPrefix(response, "SSH-") {
			service = "ssh"
			re := regexp.MustCompile(`SSH-2.0-([^\r\n]+)`)
			if matches := re.FindStringSubmatch(response); len(matches) > 1 {
				version = matches[1]
			}
			break
		}
	}

	return service, version
}

// scanTCPSyn performs a TCP SYN scan (requires root privileges)
func scanTCPSyn(ip string, port int) (string, string) {
	if os.Getuid() != 0 {
		return "error", "requires root privileges"
	}

	conn, err := net.ListenPacket("ip4:tcp", "0.0.0.0")
	if err != nil {
		return "error", "failed to create raw socket"
	}
	defer conn.Close()

	// Create the TCP header
	srcPort := 54321
	dstIP := net.ParseIP(ip)
	tcpHeader := &layers.TCP{
		SrcPort: layers.TCPPort(srcPort),
		DstPort: layers.TCPPort(port),
		SYN:     true,
		Window:  14600,
		Seq:     1234,
	}

	// Create IP header
	ipHeader := &layers.IPv4{
		SrcIP:    net.ParseIP("0.0.0.0"),
		DstIP:    dstIP,
		Protocol: layers.IPProtocolTCP,
		TTL:      64,
	}

	// Serialize the packet
	buf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		ComputeChecksums: true,
		FixLengths:       true,
	}

	err = gopacket.SerializeLayers(buf, opts, ipHeader, tcpHeader)
	if err != nil {
		return "error", "failed to serialize packet"
	}

	// Send the packet
	_, err = conn.WriteTo(buf.Bytes(), &net.IPAddr{IP: dstIP})
	if err != nil {
		return "error", "failed to send packet"
	}

	// Listen for response
	response := make([]byte, 4096)
	conn.SetReadDeadline(time.Now().Add(2 * time.Second))
	n, _, err := conn.ReadFrom(response)
	if err != nil {
		return "closed", ""
	}

	// Parse response
	packet := gopacket.NewPacket(response[:n], layers.LayerTypeTCP, gopacket.Default)
	tcpLayer := packet.Layer(layers.LayerTypeTCP)
	if tcpLayer == nil {
		return "closed", ""
	}

	tcp, _ := tcpLayer.(*layers.TCP)
	if tcp.SYN && tcp.ACK {
		return "open", getServiceName(port)
	}

	return "closed", ""
}

// detectOS attempts to fingerprint the operating system
func detectOS(ip string) string {
	// Common TTL values for different OS types
	ttls := map[int]string{
		64:  "Linux/Unix",
		128: "Windows",
		255: "Network Device",
	}

	// Try common ports for OS detection
	commonPorts := []int{80, 443, 22, 21}
	var initialTTL int
	var detected bool

	// Use raw socket to get TTL
	for _, port := range commonPorts {
		// Create a TCP connection
		conn, err := net.DialTimeout("tcp", net.JoinHostPort(ip, strconv.Itoa(port)), time.Second)
		if err == nil {
			if tcpConn, ok := conn.(*net.TCPConn); ok {
				// Get raw connection info
				file, err := tcpConn.File()
				if err == nil {
					// Get socket information
					fd := int(file.Fd())
					ttl, err := syscall.GetsockoptInt(fd, syscall.IPPROTO_IP, syscall.IP_TTL)
					if err == nil {
						initialTTL = ttl
						detected = true
					}
					file.Close()
				}
			}
			conn.Close()
			if detected {
				break
			}
		}
	}

	// If we got a valid TTL, try to determine the OS
	if detected {
		if os, ok := ttls[initialTTL]; ok {
			// Try additional TCP fingerprinting
			if conn, err := net.DialTimeout("tcp", net.JoinHostPort(ip, "80"), time.Second); err == nil {
				defer conn.Close()
				if tcpConn, ok := conn.(*net.TCPConn); ok {
					// Get additional TCP parameters if possible
					if f, err := tcpConn.File(); err == nil {
						defer f.Close()
						// Could add more OS fingerprinting checks here
						return fmt.Sprintf("%s (TTL: %d)", os, initialTTL)
					}
				}
			}
			return fmt.Sprintf("%s (TTL: %d)", os, initialTTL)
		}
		return fmt.Sprintf("Unknown OS (TTL: %d)", initialTTL)
	}

	return "OS detection failed"
}
