package pentest

import (
	"fmt"
	"net"
	"strconv"
	"strings"
	"sync"
	"time"

	"secshell/drawbox"
	"secshell/logging"
)

// ScanResult stores the result of a port scan
type ScanResult struct {
	Port    int
	State   string
	Service string
}

// RunPortScan performs a port scan using native Go networking
func RunPortScan(target string, portRange string) {
	if portRange == "" {
		portRange = "1-1000" // Default port range
	}

	drawbox.RunDrawbox(fmt.Sprintf("Port Scan for %s (ports %s)", target, portRange), "bold_cyan")

	// Parse port range
	start, end := parsePortRange(portRange)
	if start < 1 || end > 65535 || start > end {
		drawbox.PrintError("Invalid port range. Must be between 1-65535")
		return
	}

	fmt.Printf("Starting scan on %s (%d ports)\n", target, end-start+1)
	startTime := time.Now()

	// Resolve IP address
	ips, err := net.LookupIP(target)
	if err != nil || len(ips) == 0 {
		logging.LogError(fmt.Errorf("could not resolve %s: %v", target, err))
		drawbox.PrintError(fmt.Sprintf("Could not resolve host: %s", target))
		return
	}

	ip := ips[0].String()
	fmt.Printf("Scanning IP: %s\n\n", ip)

	// Start scanning ports
	results := scanPorts(ip, start, end)

	// Print results
	fmt.Printf("\nScan completed in %.2f seconds\n", time.Since(startTime).Seconds())
	fmt.Printf("%-6s %-10s %s\n", "PORT", "STATE", "SERVICE")
	fmt.Println(strings.Repeat("-", 40))

	for _, result := range results {
		fmt.Printf("%-6d %-10s %s\n", result.Port, result.State, result.Service)
	}
}

// parsePortRange converts a string like "80-100" into start and end integers
func parsePortRange(portRange string) (int, int) {
	parts := strings.Split(portRange, "-")
	if len(parts) == 1 {
		// Single port
		port, _ := strconv.Atoi(parts[0])
		return port, port
	}

	// Port range
	start, _ := strconv.Atoi(parts[0])
	end, _ := strconv.Atoi(parts[1])
	return start, end
}

// scanPorts scans a range of ports on a target IP
func scanPorts(ip string, start, end int) []ScanResult {
	var results []ScanResult
	var mutex sync.Mutex
	var wg sync.WaitGroup

	// Limit concurrency
	semaphore := make(chan struct{}, 100)

	for port := start; port <= end; port++ {
		wg.Add(1)
		semaphore <- struct{}{} // Acquire token

		go func(p int) {
			defer wg.Done()
			defer func() { <-semaphore }() // Release token

			// Try to connect with a timeout
			address := net.JoinHostPort(ip, strconv.Itoa(p))
			conn, err := net.DialTimeout("tcp", address, 2*time.Second)

			if err == nil {
				// Port is open
				defer conn.Close()
				service := getServiceName(p)

				mutex.Lock()
				results = append(results, ScanResult{
					Port:    p,
					State:   "open",
					Service: service,
				})
				fmt.Printf("\rFound open port: %d/%s", p, service)
				mutex.Unlock()
			}
		}(port)
	}

	wg.Wait()
	fmt.Println() // End the progress line
	return results
}

// getServiceName returns a service name for common ports
func getServiceName(port int) string {
	services := map[int]string{
		21:    "ftp",
		22:    "ssh",
		23:    "telnet",
		25:    "smtp",
		53:    "dns",
		80:    "http",
		110:   "pop3",
		143:   "imap",
		443:   "https",
		445:   "smb",
		3306:  "mysql",
		3389:  "rdp",
		5432:  "postgresql",
		8080:  "http-alt",
		27017: "mongodb",
	}

	if service, ok := services[port]; ok {
		return service
	}
	return "unknown"
}

// RunHostDiscovery performs host discovery on a network
func RunHostDiscovery(network string) {
	drawbox.RunDrawbox(fmt.Sprintf("Host Discovery on %s", network), "bold_cyan")

	// Parse CIDR notation
	ip, ipnet, err := net.ParseCIDR(network)
	if err != nil {
		logging.LogError(err)
		drawbox.PrintError(fmt.Sprintf("Invalid network format: %s (use CIDR notation, e.g., 192.168.1.0/24)", network))
		return
	}

	fmt.Printf("Scanning network: %s\n\n", network)
	startTime := time.Now()

	// Get all IPs in this subnet
	var ips []net.IP
	for ip := ip.Mask(ipnet.Mask); ipnet.Contains(ip); incrementIP(ip) {
		ips = append(ips, duplicateIP(ip))
	}

	// Don't scan network or broadcast addresses
	if len(ips) > 2 {
		ips = ips[1 : len(ips)-1]
	}

	fmt.Printf("Scanning %d potential hosts...\n", len(ips))

	// Start scanning hosts
	var wg sync.WaitGroup
	var mutex sync.Mutex
	var liveHosts []string

	// Limit concurrency
	semaphore := make(chan struct{}, 100)

	for _, ip := range ips {
		wg.Add(1)
		semaphore <- struct{}{} // Acquire token

		go func(ipAddr net.IP) {
			defer wg.Done()
			defer func() { <-semaphore }() // Release token

			// Try ICMP ping first (might not work without privileges)
			isAlive := pingHost(ipAddr.String())

			// If ping failed, try a TCP connection to common ports
			if !isAlive {
				commonPorts := []int{80, 443, 22, 21, 3389}
				for _, port := range commonPorts {
					address := net.JoinHostPort(ipAddr.String(), strconv.Itoa(port))
					conn, err := net.DialTimeout("tcp", address, 500*time.Millisecond)
					if err == nil {
						conn.Close()
						isAlive = true
						break
					}
				}
			}

			if isAlive {
				mutex.Lock()
				fmt.Printf("\rFound live host: %s", ipAddr.String())
				liveHosts = append(liveHosts, ipAddr.String())
				mutex.Unlock()
			}
		}(ip)
	}

	wg.Wait()
	fmt.Println() // End the progress line

	// Print results
	fmt.Printf("\nScan completed in %.2f seconds\n", time.Since(startTime).Seconds())
	fmt.Printf("Found %d live hosts:\n", len(liveHosts))
	fmt.Println(strings.Repeat("-", 40))

	for _, host := range liveHosts {
		hostname, _ := net.LookupAddr(host)
		if len(hostname) > 0 {
			fmt.Printf("%s (%s)\n", host, hostname[0])
		} else {
			fmt.Println(host)
		}
	}
}

// incrementIP increments an IP address by 1
func incrementIP(ip net.IP) {
	for i := len(ip) - 1; i >= 0; i-- {
		ip[i]++
		if ip[i] > 0 {
			break
		}
	}
}

// duplicateIP creates a copy of an IP address
func duplicateIP(ip net.IP) net.IP {
	dup := make(net.IP, len(ip))
	copy(dup, ip)
	return dup
}

// pingHost attempts to ping a host
func pingHost(ip string) bool {
	// Simple connect to echo port (port 7)
	conn, err := net.DialTimeout("tcp", ip+":7", 500*time.Millisecond)
	if err == nil {
		conn.Close()
		return true
	}

	// Try a TCP ping to port 80
	conn, err = net.DialTimeout("tcp", ip+":80", 500*time.Millisecond)
	if err == nil {
		conn.Close()
		return true
	}

	return false
}
