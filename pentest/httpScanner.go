package pentest

import (
	"crypto/tls"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"secshell/drawbox"
	"secshell/logging"
	"strings"
	"time"
)

// WebScan performs a basic web security scan
func WebScan(targetURL string) {
	drawbox.RunDrawbox(fmt.Sprintf("Web Security Scan for %s", targetURL), "bold_red")

	// Ensure URL has a scheme
	if !strings.HasPrefix(targetURL, "http://") && !strings.HasPrefix(targetURL, "https://") {
		targetURL = "http://" + targetURL
	}

	// Parse the URL
	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		logging.LogError(err)
		drawbox.PrintError(fmt.Sprintf("Invalid URL: %s", err))
		return
	}

	// Create HTTP client with relaxed TLS verification and timeout
	client := &http.Client{
		Timeout: 10 * time.Second,
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
		},
	}

	// Check if server is reachable
	fmt.Printf("Connecting to %s...\n", targetURL)
	resp, err := client.Get(targetURL)
	if err != nil {
		logging.LogError(err)
		drawbox.PrintError(fmt.Sprintf("Failed to connect: %s", err))
		return
	}
	defer resp.Body.Close()

	// Basic server information
	fmt.Printf("\n%s Server Information %s\n", strings.Repeat("-", 10), strings.Repeat("-", 10))
	fmt.Printf("Status: %s\n", resp.Status)
	fmt.Printf("Server: %s\n", resp.Header.Get("Server"))
	fmt.Printf("Content-Type: %s\n", resp.Header.Get("Content-Type"))

	// Security headers check
	fmt.Printf("\n%s Security Headers Analysis %s\n", strings.Repeat("-", 10), strings.Repeat("-", 10))
	checkSecurityHeaders(resp.Header)

	// Try common directories
	fmt.Printf("\n%s Directory Scan %s\n", strings.Repeat("-", 10), strings.Repeat("-", 10))
	scanCommonDirectories(client, parsedURL)

	// Test for common vulnerabilities
	fmt.Printf("\n%s Vulnerability Tests %s\n", strings.Repeat("-", 10), strings.Repeat("-", 10))
	testCommonVulnerabilities(client, parsedURL)
}

// checkSecurityHeaders examines HTTP headers for security best practices
func checkSecurityHeaders(headers http.Header) {
	securityHeaders := map[string]string{
		"Content-Security-Policy":   "Prevents XSS and data injection attacks",
		"X-XSS-Protection":          "Stops pages from loading when reflected XSS detected",
		"X-Frame-Options":           "Prevents clickjacking attacks",
		"X-Content-Type-Options":    "Prevents MIME-sniffing",
		"Strict-Transport-Security": "Enforces HTTPS connections",
		"Referrer-Policy":           "Controls information in the referer header",
		"Permissions-Policy":        "Controls browser features",
	}

	for header, description := range securityHeaders {
		value := headers.Get(header)
		if value == "" {
			fmt.Printf("‚ùå %s: Not present (%s)\n", header, description)
		} else {
			fmt.Printf("‚úÖ %s: %s\n", header, value)
		}
	}

	// Check for cookies and their security attributes
	cookies := headers["Set-Cookie"]
	if len(cookies) > 0 {
		fmt.Println("\nCookie Analysis:")
		for _, cookie := range cookies {
			fmt.Printf("Cookie: %s\n", cookie)
			if !strings.Contains(strings.ToLower(cookie), "secure") {
				fmt.Printf("  ‚ö†Ô∏è Cookie missing 'Secure' flag\n")
			}
			if !strings.Contains(strings.ToLower(cookie), "httponly") {
				fmt.Printf("  ‚ö†Ô∏è Cookie missing 'HttpOnly' flag\n")
			}
			if !strings.Contains(strings.ToLower(cookie), "samesite") {
				fmt.Printf("  ‚ö†Ô∏è Cookie missing 'SameSite' attribute\n")
			}
		}
	}
}

// scanCommonDirectories checks for common sensitive directories
func scanCommonDirectories(client *http.Client, baseURL *url.URL) {
	commonPaths := []string{
		"/admin", "/login", "/wp-login.php", "/administrator", "/phpmyadmin",
		"/backup", "/wp-admin", "/config", "/backup", "/db", "/logs",
		"/.git", "/.env", "/api", "/test", "/debug", "/console",
	}

	for _, path := range commonPaths {
		targetURL := baseURL.Scheme + "://" + baseURL.Host + path
		resp, err := client.Head(targetURL)

		if err != nil {
			continue
		}

		defer resp.Body.Close()

		if resp.StatusCode == 200 || resp.StatusCode == 301 || resp.StatusCode == 302 || resp.StatusCode == 403 {
			status := ""
			switch resp.StatusCode {
			case 200:
				status = "Found"
			case 301, 302:
				status = "Redirect"
			case 403:
				status = "Forbidden"
			}

			fmt.Printf("üìÅ %s: %s (Status: %d - %s)\n", path, status, resp.StatusCode, http.StatusText(resp.StatusCode))
		}
	}
}

// testCommonVulnerabilities checks for common web vulnerabilities
func testCommonVulnerabilities(client *http.Client, baseURL *url.URL) {
	// Test for SQL injection
	sqliTests := []string{
		"?id=1'",
		"?page_id=1+OR+1=1",
		"?id=1+UNION+SELECT+1,2",
	}

	for _, test := range sqliTests {
		testURL := baseURL.String() + test
		resp, err := client.Get(testURL)
		if err != nil {
			continue
		}

		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()

		bodyStr := string(body)
		if strings.Contains(bodyStr, "SQL syntax") ||
			strings.Contains(bodyStr, "mysql_fetch") ||
			strings.Contains(bodyStr, "ORA-") ||
			strings.Contains(bodyStr, "PostgreSQL") {
			fmt.Printf("‚ö†Ô∏è Potential SQL Injection vulnerability found with: %s\n", test)
		}
	}

	// Test for XSS vulnerabilities
	xssTests := []string{
		"?q=<script>alert(1)</script>",
		"?search=<img src=x onerror=alert('XSS')>",
	}

	for _, test := range xssTests {
		testURL := baseURL.String() + test
		resp, err := client.Get(testURL)
		if err != nil {
			continue
		}

		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()

		bodyStr := string(body)
		payload := strings.Split(test, "=")[1]
		if strings.Contains(bodyStr, payload) {
			fmt.Printf("‚ö†Ô∏è Potential XSS vulnerability found with: %s\n", test)
		}
	}

	// Check for open redirect
	redirectTests := []string{
		"?redirect=https://example.com",
		"?url=https://example.com",
		"?next=https://example.com",
	}

	for _, test := range redirectTests {
		testURL := baseURL.String() + test
		req, _ := http.NewRequest("GET", testURL, nil)
		resp, err := client.Do(req)
		if err != nil {
			continue
		}
		resp.Body.Close()

		if resp.Request.URL.Host == "example.com" {
			fmt.Printf("‚ö†Ô∏è Potential Open Redirect vulnerability found with: %s\n", test)
		}
	}

	// Look for information disclosure
	fmt.Println("\nChecking for information disclosure...")
	infoLeakPaths := []string{"/robots.txt", "/sitemap.xml", "/crossdomain.xml", "/clientaccesspolicy.xml"}

	for _, path := range infoLeakPaths {
		targetURL := baseURL.Scheme + "://" + baseURL.Host + path
		resp, err := client.Get(targetURL)
		if err != nil {
			continue
		}

		if resp.StatusCode == 200 {
			body, _ := io.ReadAll(resp.Body)
			fmt.Printf("üìÑ Found %s (%d bytes)\n", path, len(body))

			// Show first few lines
			lines := strings.Split(string(body), "\n")
			previewLines := 5
			if len(lines) < previewLines {
				previewLines = len(lines)
			}

			fmt.Printf("   Preview: %s\n", strings.Join(lines[:previewLines], "\n   "))
		}
		resp.Body.Close()
	}
}
