package pentest

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"secshell/drawbox"
	"secshell/logging"
	"strings"
	"sync"
	"time"
)

// WebScanOptions holds configuration for web security scanning
type WebScanOptions struct {
	Timeout        int
	CustomHeaders  map[string]string
	UserAgent      string
	Threads        int
	CustomPaths    []string
	OutputFormat   string
	OutputFile     string
	ProxyURL       string
	Cookies        string
	Authentication string
	SkipSSL        bool
	FollowRedirect bool
	MaxDepth       int
	VerboseMode    bool
	TestMethods    []string
	WordlistPath   string
	StealthMode    bool     // Adds delays and randomization
	RateLimit      int      // Requests per second
	ExcludePaths   []string // Paths to skip (dangerous endpoints)
	SafetyChecks   bool     // Verify target is testable
	Fingerprint    bool     // Enhanced fingerprinting
}

// WebScanResult holds the results of the web security scan
type WebScanResult struct {
	TargetURL       string            `json:"target_url"`
	ServerInfo      map[string]string `json:"server_info"`
	SecurityHeaders map[string]string `json:"security_headers"`
	Findings        []Finding         `json:"findings"`
	mu              sync.Mutex        // Add mutex for concurrent access
}

// AddFinding safely adds a finding to the results
func (r *WebScanResult) AddFinding(f Finding) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.Findings = append(r.Findings, f)
}

// AddAndPrintFinding adds a finding and prints it
func (r *WebScanResult) AddAndPrintFinding(f Finding) {
	r.AddFinding(f)
	f.Print()
}

// Finding represents a single finding in the web security scan
type Finding struct {
	Type        string `json:"type"`
	Description string `json:"description"`
	Severity    string `json:"severity"`
	Details     string `json:"details,omitempty"`
}

// PrintFinding prints a finding to the console with color coding
func (f Finding) Print() {
	var color string
	switch f.Severity {
	case "High":
		color = "\033[31m" // Red
	case "Medium":
		color = "\033[33m" // Yellow
	case "Low":
		color = "\033[36m" // Cyan
	default:
		color = "\033[37m" // White
	}
	reset := "\033[0m"
	fmt.Printf("%s[%s] %s%s\n", color, f.Severity, f.Description, reset)
	if f.Details != "" {
		fmt.Printf("  └─ %s\n", f.Details)
	}
}

// WebScan performs a web security scan
func WebScan(targetURL string, options *WebScanOptions) *WebScanResult {
	drawbox.RunDrawbox(fmt.Sprintf("Web Security Scan for %s", targetURL), "bold_cyan")
	fmt.Println("\n Starting security scan...")

	results := &WebScanResult{
		TargetURL:       targetURL,
		ServerInfo:      make(map[string]string),
		SecurityHeaders: make(map[string]string),
		Findings:        []Finding{},
	}

	// Ensure URL has a scheme
	if !strings.HasPrefix(targetURL, "http://") && !strings.HasPrefix(targetURL, "https://") {
		targetURL = "http://" + targetURL
	}

	// Perform safety checks
	if options.SafetyChecks && !performSafetyChecks(targetURL) {
		drawbox.PrintError("Target is restricted or unsafe for testing.")
		return results
	}

	// Parse the URL
	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		logging.LogError(err)
		drawbox.PrintError(fmt.Sprintf("Invalid URL: %s", err))
		return results
	}

	// Configure HTTP client with options
	client := &http.Client{
		Timeout: time.Duration(options.Timeout) * time.Second,
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: options.SkipSSL,
			},
			Proxy: func(_ *http.Request) (*url.URL, error) {
				if options.ProxyURL != "" {
					return url.Parse(options.ProxyURL)
				}
				return nil, nil
			},
		},
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			if !options.FollowRedirect || len(via) >= options.MaxDepth {
				return http.ErrUseLastResponse
			}
			return nil
		},
	}

	// Apply rate limiting if enabled
	if options.RateLimit > 0 {
		client = rateLimit(options.RateLimit, client)
	}

	fmt.Printf("\n Testing connection to %s...\n", targetURL)
	resp, err := client.Get(targetURL)
	if err != nil {
		logging.LogError(err)
		drawbox.PrintError(fmt.Sprintf("Failed to connect: %s", err))
		return results
	}
	defer resp.Body.Close()

	fmt.Printf("\n Server Information:\n")
	fmt.Printf("├─ Status: %s\n", resp.Status)
	fmt.Printf("├─ Server: %s\n", resp.Header.Get("Server"))
	fmt.Printf("└─ Content-Type: %s\n", resp.Header.Get("Content-Type"))

	fmt.Printf("\n Checking security headers...\n")
	checkSecurityHeaders(resp.Header, results)

	fmt.Printf("\n Scanning directories...\n")
	scanCommonDirectories(client, parsedURL, results)

	fmt.Printf("\n Testing for vulnerabilities...\n")
	testCommonVulnerabilities(client, parsedURL, results)
	testAdditionalVulnerabilities(client, parsedURL, results)

	if len(options.TestMethods) > 0 {
		fmt.Printf("\n Testing HTTP methods: %s\n", strings.Join(options.TestMethods, ", "))
		testHTTPMethods(client, parsedURL, options.TestMethods, results)
	}

	if options.WordlistPath != "" {
		fmt.Printf("\n Scanning with custom wordlist: %s\n", options.WordlistPath)
		scanCustomWordlist(client, parsedURL, options.WordlistPath, results)
	}

	if options.VerboseMode {
		fmt.Printf("\n Testing API endpoints...\n")
		testAPIEndpoints(client, parsedURL, results)
	}

	fmt.Printf("\n Checking for misconfigurations...\n")
	testMisconfiguration(client, parsedURL, results)

	fmt.Printf("\n Scanning for sensitive files...\n")
	testSensitiveFiles(client, parsedURL, results)

	fmt.Printf("\n Detecting web technologies...\n")
	checkWebTechnologies(client, parsedURL, results)

	fmt.Printf("\n Testing CORS configuration...\n")
	testCORSMisconfiguration(client, parsedURL, results)

	// Print summary
	fmt.Printf("\n Scan Summary:\n")
	fmt.Printf("├─ Total Findings: %d\n", len(results.Findings))

	severityCounts := map[string]int{"High": 0, "Medium": 0, "Low": 0, "Info": 0}
	for _, f := range results.Findings {
		severityCounts[f.Severity]++
	}

	fmt.Printf("├─ High Severity: %d\n", severityCounts["High"])
	fmt.Printf("├─ Medium Severity: %d\n", severityCounts["Medium"])
	fmt.Printf("├─ Low Severity: %d\n", severityCounts["Low"])
	fmt.Printf("└─ Informational: %d\n", severityCounts["Info"])

	// Save results if output format is specified
	if options.OutputFormat != "" && options.OutputFile != "" {
		fmt.Printf("\n Saving results to %s...\n", options.OutputFile)
		if err := saveWebScanResults(results, options); err != nil {
			drawbox.PrintError(fmt.Sprintf("Failed to save results: %s", err))
		} else {
			drawbox.PrintAlert(fmt.Sprintf("Results saved to: %s", options.OutputFile))
		}
	}

	return results
}

// checkSecurityHeaders examines HTTP headers for security best practices
func checkSecurityHeaders(headers http.Header, results *WebScanResult) {
	securityHeaders := map[string]string{
		"Content-Security-Policy":   "Prevents XSS and data injection attacks",
		"X-XSS-Protection":          "Stops pages from loading when reflected XSS detected",
		"X-Frame-Options":           "Prevents clickjacking attacks",
		"X-Content-Type-Options":    "Prevents MIME-sniffing",
		"Strict-Transport-Security": "Enforces HTTPS connections",
		"Referrer-Policy":           "Controls information in the referer header",
		"Permissions-Policy":        "Controls browser features",
	}

	for header, description := range securityHeaders {
		value := headers.Get(header)
		results.SecurityHeaders[header] = value
		if value == "" {
			results.AddAndPrintFinding(Finding{
				Type:        "Missing Security Header",
				Description: fmt.Sprintf("Missing %s header (%s)", header, description),
				Severity:    "Medium",
			})
		}
	}

	// Check for cookies and their security attributes
	cookies := headers["Set-Cookie"]
	if len(cookies) > 0 {
		fmt.Println("\nCookie Analysis:")
		for _, cookie := range cookies {
			fmt.Printf("Cookie: %s\n", cookie)
			if !strings.Contains(strings.ToLower(cookie), "secure") {
				results.AddAndPrintFinding(Finding{
					Type:        "Insecure Cookie",
					Description: "Cookie missing 'Secure' flag",
					Severity:    "Low",
				})
			}
			if !strings.Contains(strings.ToLower(cookie), "httponly") {
				results.AddAndPrintFinding(Finding{
					Type:        "Insecure Cookie",
					Description: "Cookie missing 'HttpOnly' flag",
					Severity:    "Low",
				})
			}
			if !strings.Contains(strings.ToLower(cookie), "samesite") {
				results.AddAndPrintFinding(Finding{
					Type:        "Insecure Cookie",
					Description: "Cookie missing 'SameSite' attribute",
					Severity:    "Low",
				})
			}
		}
	}
}

// scanCommonDirectories checks for common sensitive directories
func scanCommonDirectories(client *http.Client, baseURL *url.URL, results *WebScanResult) {
	commonPaths := []string{
		"/admin", "/login", "/wp-login.php", "/administrator", "/phpmyadmin",
		"/backup", "/wp-admin", "/config", "/backup", "/db", "/logs",
		"/.git", "/.env", "/api", "/test", "/debug", "/console",
	}

	for _, path := range commonPaths {
		targetURL := baseURL.Scheme + "://" + baseURL.Host + path
		resp, err := client.Head(targetURL)

		if err != nil {
			continue
		}

		defer resp.Body.Close()

		if resp.StatusCode == 200 || resp.StatusCode == 301 || resp.StatusCode == 302 || resp.StatusCode == 403 {
			status := ""
			switch resp.StatusCode {
			case 200:
				status = "Found"
			case 301, 302:
				status = "Redirect"
			case 403:
				status = "Forbidden"
			}

			results.AddAndPrintFinding(Finding{
				Type:        "Directory Found",
				Description: fmt.Sprintf("Found accessible directory: %s", path),
				Severity:    "Low",
				Details:     fmt.Sprintf("Status: %d - %s (%s)", resp.StatusCode, http.StatusText(resp.StatusCode), status),
			})
		}
	}
}

// testCommonVulnerabilities checks for common web vulnerabilities
func testCommonVulnerabilities(client *http.Client, baseURL *url.URL, results *WebScanResult) {
	// Test for SQL injection
	sqliTests := []string{
		"?id=1'",
		"?page_id=1+OR+1=1",
		"?id=1+UNION+SELECT+1,2",
	}

	for _, test := range sqliTests {
		testURL := baseURL.String() + test
		resp, err := client.Get(testURL)
		if err != nil {
			continue
		}

		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()

		bodyStr := string(body)
		if strings.Contains(bodyStr, "SQL syntax") ||
			strings.Contains(bodyStr, "mysql_fetch") ||
			strings.Contains(bodyStr, "ORA-") ||
			strings.Contains(bodyStr, "PostgreSQL") {
			results.AddAndPrintFinding(Finding{
				Type:        "SQL Injection",
				Description: fmt.Sprintf("Potential SQL Injection vulnerability found with: %s", test),
				Severity:    "High",
			})
		}
	}

	// Test for XSS vulnerabilities
	xssTests := []string{
		"?q=<script>alert(1)</script>",
		"?search=<img src=x onerror=alert('XSS')>",
	}

	for _, test := range xssTests {
		testURL := baseURL.String() + test
		resp, err := client.Get(testURL)
		if err != nil {
			continue
		}

		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()

		bodyStr := string(body)
		payload := strings.Split(test, "=")[1]
		if strings.Contains(bodyStr, payload) {
			results.AddAndPrintFinding(Finding{
				Type:        "Cross-Site Scripting (XSS)",
				Description: fmt.Sprintf("Potential XSS vulnerability found with: %s", test),
				Severity:    "High",
			})
		}
	}

	// Check for open redirect
	redirectTests := []string{
		"?redirect=https://example.com",
		"?url=https://example.com",
		"?next=https://example.com",
	}

	for _, test := range redirectTests {
		testURL := baseURL.String() + test
		req, _ := http.NewRequest("GET", testURL, nil)
		resp, err := client.Do(req)
		if err != nil {
			continue
		}
		resp.Body.Close()

		if resp.Request.URL.Host == "example.com" {
			results.AddAndPrintFinding(Finding{
				Type:        "Open Redirect",
				Description: fmt.Sprintf("Potential Open Redirect vulnerability found with: %s", test),
				Severity:    "Medium",
			})
		}
	}

	// Look for information disclosure
	infoLeakPaths := []string{"/robots.txt", "/sitemap.xml", "/crossdomain.xml", "/clientaccesspolicy.xml"}

	for _, path := range infoLeakPaths {
		targetURL := baseURL.Scheme + "://" + baseURL.Host + path
		resp, err := client.Get(targetURL)
		if err != nil {
			continue
		}

		if resp.StatusCode == 200 {
			body, _ := io.ReadAll(resp.Body)
			results.AddAndPrintFinding(Finding{
				Type:        "Information Disclosure",
				Description: fmt.Sprintf("Found %s (%d bytes)", path, len(body)),
				Severity:    "Low",
			})
		}
		resp.Body.Close()
	}
}

// testAdditionalVulnerabilities checks for additional web vulnerabilities
func testAdditionalVulnerabilities(client *http.Client, baseURL *url.URL, results *WebScanResult) {
	// Test for Log4j
	log4jPayloads := []string{
		"${jndi:ldap://example.com/a}",
		"${${::-j}${::-n}${::-d}${::-i}:${::-r}${::-m}${::-i}://example.com/a}",
	}

	// Test each Log4j payload
	for _, payload := range log4jPayloads {
		req, _ := http.NewRequest("GET", baseURL.String(), nil)
		req.Header.Set("User-Agent", payload)
		req.Header.Set("X-Api-Version", payload)

		resp, err := client.Do(req)
		if err != nil {
			continue
		}
		resp.Body.Close()

		// Check response time as Log4j vulnerabilities often cause delays
		if resp.StatusCode == 500 || resp.StatusCode == 404 {
			results.AddAndPrintFinding(Finding{
				Type:        "Log4j Potential Vulnerability",
				Description: "Server might be vulnerable to Log4j exploitation",
				Severity:    "High",
				Details:     fmt.Sprintf("Tested payload: %s - Status: %d", payload, resp.StatusCode),
			})
		}
	}

	// Test for SSRF
	ssrfTests := []string{
		"?url=http://169.254.169.254/",
		"?path=file:///etc/passwd",
	}

	// Test each SSRF payload
	for _, test := range ssrfTests {
		testURL := baseURL.String() + test
		resp, err := client.Get(testURL)
		if err != nil {
			continue
		}

		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()

		// Check for potential SSRF indicators
		if resp.StatusCode == 200 && len(body) > 0 {
			results.AddAndPrintFinding(Finding{
				Type:        "SSRF",
				Description: fmt.Sprintf("Potential SSRF vulnerability found with: %s", test),
				Severity:    "High",
				Details:     "Server responded with status 200 and returned content",
			})
		}
	}

	// Test for NoSQL Injection
	nosqlTests := []string{
		"?id[$ne]=1",
		"?user[$exists]=true",
	}

	// Test NoSQL injection payloads
	for _, test := range nosqlTests {
		testURL := baseURL.String() + test
		resp, err := client.Get(testURL)
		if err != nil {
			continue
		}
		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()

		// Check for potential NoSQL indicators in response
		if resp.StatusCode == 200 && (strings.Contains(string(body), "[{") || strings.Contains(string(body), "]}")) {
			results.AddAndPrintFinding(Finding{
				Type:        "NoSQL Injection",
				Description: fmt.Sprintf("Potential NoSQL Injection vulnerability found with: %s", test),
				Severity:    "High",
				Details:     "Server response suggests successful NoSQL operation",
			})
		}
	}

	// Test for Server-Side Template Injection
	sstiTests := []string{
		"{{7*7}}",
		"${7*7}",
		"<%= 7*7 %>",
	}

	for _, test := range sstiTests {
		testURL := baseURL.String() + "?test=" + url.QueryEscape(test)
		resp, err := client.Get(testURL)
		if err != nil {
			continue
		}
		body, _ := io.ReadAll(resp.Body)
		resp.Body.Close()

		// Check if response contains "49" which would indicate template execution
		if strings.Contains(string(body), "49") {
			results.AddAndPrintFinding(Finding{
				Type:        "Server-Side Template Injection",
				Description: fmt.Sprintf("Potential SSTI vulnerability found with: %s", test),
				Severity:    "High",
				Details:     "Server appears to be executing template expressions",
			})
		}
	}
}

func testHTTPMethods(client *http.Client, baseURL *url.URL, methods []string, results *WebScanResult) {
	for _, method := range methods {
		req, _ := http.NewRequest(method, baseURL.String(), nil)
		resp, err := client.Do(req)
		if err != nil {
			continue
		}
		defer resp.Body.Close()
		if resp.StatusCode == 200 {
			results.AddAndPrintFinding(Finding{
				Type:        "HTTP Method Enabled",
				Description: fmt.Sprintf("Method %s is enabled and might be dangerous if not properly configured", method),
				Severity:    "Medium",
			})
		}
	}
}

func scanCustomWordlist(client *http.Client, baseURL *url.URL, wordlistPath string, results *WebScanResult) {
	content, err := os.ReadFile(wordlistPath)
	if err != nil {
		drawbox.PrintError(fmt.Sprintf("Failed to read wordlist: %s", err))
		return
	}

	paths := strings.Split(string(content), "\n")
	var wg sync.WaitGroup
	semaphore := make(chan struct{}, 10) // Limit concurrent requests

	for _, path := range paths {
		wg.Add(1)
		semaphore <- struct{}{}

		go func(p string) {
			defer wg.Done()
			defer func() { <-semaphore }()

			targetURL := baseURL.String() + "/" + strings.TrimSpace(p)
			resp, err := client.Head(targetURL)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode == 200 || resp.StatusCode == 403 {
				results.AddAndPrintFinding(Finding{
					Type:        "Custom Directory Found",
					Description: fmt.Sprintf("Found: %s", p),
					Severity:    "Low",
				})
			}
		}(path)
	}

	wg.Wait()
}

func testAPIEndpoints(client *http.Client, baseURL *url.URL, results *WebScanResult) {
	commonAPIPaths := []string{
		"/api/v1/users", "/api/v2/users", "/api/users",
		"/api/admin", "/api/config", "/api/settings",
		"/v1/auth", "/v2/auth", "/graphql",
		"/api/swagger", "/api-docs", "/swagger-ui",
	}

	for _, path := range commonAPIPaths {
		targetURL := baseURL.String() + path
		resp, err := client.Get(targetURL)
		if err != nil {
			continue
		}
		defer resp.Body.Close()

		if resp.StatusCode != 404 {
			results.AddAndPrintFinding(Finding{
				Type:        "API Endpoint Found",
				Description: fmt.Sprintf("API Endpoint: %s (Status: %d)", path, resp.StatusCode),
				Severity:    "Low",
			})
		}
	}
}

func testMisconfiguration(client *http.Client, baseURL *url.URL, results *WebScanResult) {
	debugPaths := []string{
		"/debug/vars", "/debug/pprof", "/debug/ping",
		"/env", "/phpinfo.php", "/server-status",
		"/actuator", "/metrics", "/config",
	}

	for _, path := range debugPaths {
		targetURL := baseURL.String() + path
		resp, err := client.Get(targetURL)
		if err != nil {
			continue
		}
		defer resp.Body.Close()

		if resp.StatusCode == 200 {
			results.AddAndPrintFinding(Finding{
				Type:        "Exposed Debug Endpoint",
				Description: fmt.Sprintf("Debug endpoint exposed: %s", path),
				Severity:    "Medium",
			})
		}
	}
}

func testSensitiveFiles(client *http.Client, baseURL *url.URL, results *WebScanResult) {
	sensitiveFiles := []string{
		"/.git/config", "/.env", "/wp-config.php.bak",
		"/.htaccess", "/backup.sql", "/dump.sql",
		"/credentials.xml", "/config.yml", "/.dockerignore",
		"/id_rsa", "/.bash_history", "/.svn/entries",
		"/composer.json", "/package.json", "/yarn.lock",
		"/.gitlab-ci.yml", "/.travis.yml", "/Dockerfile",
		"/README.md", "/CHANGELOG.md", "/LICENSE",
	}

	var wg sync.WaitGroup
	semaphore := make(chan struct{}, 5) // Limit concurrent requests

	for _, file := range sensitiveFiles {
		wg.Add(1)
		semaphore <- struct{}{}

		go func(path string) {
			defer wg.Done()
			defer func() { <-semaphore }()

			targetURL := baseURL.String() + path
			resp, err := client.Head(targetURL)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode == 200 {
				results.AddAndPrintFinding(Finding{
					Type:        "Sensitive File Found",
					Description: fmt.Sprintf("Found sensitive file: %s", path),
					Severity:    "High",
				})
			}
		}(file)
	}

	wg.Wait()
}

func checkWebTechnologies(client *http.Client, baseURL *url.URL, results *WebScanResult) {
	resp, err := client.Get(baseURL.String())
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return
	}
	bodyStr := string(body)

	techSignatures := map[string][]string{
		"WordPress": {`wp-content`, `wp-includes`, `wp-admin`},
		"Laravel":   {`laravel`, `XSRF-TOKEN`, `laravel_session`},
		"Django":    {`csrfmiddlewaretoken`, `django`, `__admin__`},
		"React":     {`react`, `react-root`, `reactjs`},
		"Angular":   {`ng-`, `angular`, `ng-version`},
		"Vue.js":    {`vue`, `vuejs`, `v-`},
		"Bootstrap": {`bootstrap`, `navbar-toggle`, `container-fluid`},
		"jQuery":    {`jquery`, `jQuery`},
		"PHP":       {`php`, `.php`},
		"ASP.NET":   {`__VIEWSTATE`, `ASP.NET`, `.aspx`},
		"Node.js":   {`node_modules`, `npm`, `express`},
	}

	for tech, signatures := range techSignatures {
		for _, sig := range signatures {
			if strings.Contains(bodyStr, sig) {
				results.AddAndPrintFinding(Finding{
					Type:        "Technology Detected",
					Description: fmt.Sprintf("%s detected", tech),
					Severity:    "Info",
				})
				break
			}
		}
	}
}

func testCORSMisconfiguration(client *http.Client, baseURL *url.URL, results *WebScanResult) {
	testOrigins := []string{
		"https://evil.com",
		"http://attacker.com",
		"null",
		"*",
		"https://" + baseURL.Hostname() + ".evil.com",
	}

	for _, origin := range testOrigins {
		req, err := http.NewRequest("OPTIONS", baseURL.String(), nil)
		if err != nil {
			continue
		}

		req.Header.Set("Origin", origin)
		req.Header.Set("Access-Control-Request-Method", "POST")
		req.Header.Set("Access-Control-Request-Headers", "Authorization")

		resp, err := client.Do(req)
		if err != nil {
			continue
		}
		defer resp.Body.Close()

		allowOrigin := resp.Header.Get("Access-Control-Allow-Origin")
		allowCredentials := resp.Header.Get("Access-Control-Allow-Credentials")

		if allowOrigin != "" {
			if allowOrigin == "*" {
				results.AddAndPrintFinding(Finding{
					Type:        "CORS Misconfiguration",
					Description: "Wildcard CORS policy detected",
					Severity:    "Medium",
				})
			} else if allowOrigin == origin && origin != baseURL.String() {
				results.AddAndPrintFinding(Finding{
					Type:        "CORS Misconfiguration",
					Description: fmt.Sprintf("Permissive CORS policy for: %s", origin),
					Severity:    "Medium",
				})
			}

			if allowCredentials == "true" && (allowOrigin == "*" || strings.Contains(allowOrigin, "null")) {
				results.AddAndPrintFinding(Finding{
					Type:        "CORS Misconfiguration",
					Description: fmt.Sprintf("Credentials allowed with permissive origin: %s", allowOrigin),
					Severity:    "High",
				})
			}
		}
	}
}

func saveWebScanResults(results *WebScanResult, options *WebScanOptions) error {
	var output string

	switch options.OutputFormat {
	case "json":
		jsonData, err := json.MarshalIndent(results, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal JSON: %w", err)
		}
		output = string(jsonData)
	case "html":
		output = generateWebScanHTML(results)
	default:
		output = generateText(results)
	}

	return os.WriteFile(options.OutputFile, []byte(output), 0644)
}

func generateWebScanHTML(results *WebScanResult) string {
	return fmt.Sprintf(`<!DOCTYPE html>
<html>
<head>
    <title>Web Security Scan Results - %s</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .finding { margin: 10px 0; padding: 10px; border: 1px solid #ddd; }
        .high { border-left: 5px solid #d9534f; }
        .medium { border-left: 5px solid #f0ad4e; }
        .low { border-left: 5px solid #5bc0de; }
    </style>
</head>
<body>
    <h1>Web Security Scan Results</h1>
    <h2>Target: %s</h2>
    <div class="findings">%s</div>
    <p><small>Generated by SecShell Web Scanner</small></p>
</body>
</html>`, results.TargetURL, results.TargetURL, generateFindingsHTML(results.Findings))
}

func generateFindingsHTML(findings []Finding) string {
	var html strings.Builder
	for _, f := range findings {
		html.WriteString(fmt.Sprintf(`
        <div class="finding %s">
            <h3>%s</h3>
            <p>%s</p>
            <p>Severity: %s</p>
            %s
        </div>`,
			strings.ToLower(f.Severity),
			f.Type,
			f.Description,
			f.Severity,
			f.Details))
	}
	return html.String()
}

func generateText(results *WebScanResult) string {
	var text strings.Builder
	text.WriteString(fmt.Sprintf("Web Security Scan Results for %s\n", results.TargetURL))
	text.WriteString(strings.Repeat("=", 50) + "\n\n")

	for _, finding := range results.Findings {
		text.WriteString(fmt.Sprintf("Finding: %s\n", finding.Type))
		text.WriteString(fmt.Sprintf("Severity: %s\n", finding.Severity))
		text.WriteString(fmt.Sprintf("Description: %s\n", finding.Description))
		if finding.Details != "" {
			text.WriteString(fmt.Sprintf("Details: %s\n", finding.Details))
		}
		text.WriteString("\n")
	}

	return text.String()
}

// rateLimit adds rate limiting to the HTTP client
func rateLimit(requests int, client *http.Client) *http.Client {
	limiter := time.Tick(time.Second / time.Duration(requests))
	originalTransport := client.Transport
	if originalTransport == nil {
		originalTransport = http.DefaultTransport
	}

	client.Transport = &rateLimitedTransport{
		limiter:   limiter,
		transport: originalTransport,
	}
	return client
}

type rateLimitedTransport struct {
	limiter   <-chan time.Time
	transport http.RoundTripper
}

func (r *rateLimitedTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	<-r.limiter
	return r.transport.RoundTrip(req)
}

// performSafetyChecks ensures the target is safe for testing
func performSafetyChecks(target string) bool {
	restricted := []string{
		"localhost", "127.0.0.1", "0.0.0.0",
		".gov", ".mil", ".edu",
	}

	for _, r := range restricted {
		if strings.Contains(target, r) {
			return false
		}
	}
	return true
}
